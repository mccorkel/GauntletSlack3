// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("GauntletSlack3.Api")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+184625228a7e069bf2fe10e13b324bca60bdf1e9")]
[assembly: System.Reflection.AssemblyProductAttribute("GauntletSlack3.Api")]
[assembly: System.Reflection.AssemblyTitleAttribute("GauntletSlack3.Api")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Cors" Version="2.2.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.VisualStudio.Web.BrowserLink" Version="2.2.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.2" />
    <PackageReference Include="Azure.Identity" Version="1.10.5" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\GauntletSlack3.Shared\GauntletSlack3.Shared.csproj" />
  </ItemGroup>

</Project>
ï»¿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace GauntletSlack3.Api.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Email = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    IsAdmin = table.Column<bool>(type: "bit", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Channels",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Type = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    OwnerId = table.Column<int>(type: "int", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Channels", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Channels_Users_OwnerId",
                        column: x => x.OwnerId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "ChannelMemberships",
                columns: table => new
                {
                    ChannelId = table.Column<int>(type: "int", nullable: false),
                    UserId = table.Column<int>(type: "int", nullable: false),
                    JoinedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    IsMuted = table.Column<bool>(type: "bit", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_ChannelMemberships", x => new { x.ChannelId, x.UserId });
                    table.ForeignKey(
                        name: "FK_ChannelMemberships_Channels_ChannelId",
                        column: x => x.ChannelId,
                        principalTable: "Channels",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_ChannelMemberships_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Messages",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    UserId = table.Column<int>(type: "int", nullable: false),
                    ChannelId = table.Column<int>(type: "int", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ParentMessageId = table.Column<int>(type: "int", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Messages", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Messages_Channels_ChannelId",
                        column: x => x.ChannelId,
                        principalTable: "Channels",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Messages_Messages_ParentMessageId",
                        column: x => x.ParentMessageId,
                        principalTable: "Messages",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_Messages_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.CreateTable(
                name: "MessageReactions",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    MessageId = table.Column<int>(type: "int", nullable: false),
                    UserId = table.Column<int>(type: "int", nullable: false),
                    Emoji = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_MessageReactions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_MessageReactions_Messages_MessageId",
                        column: x => x.MessageId,
                        principalTable: "Messages",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_MessageReactions_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "Email", "IsAdmin", "Name" },
                values: new object[] { -1, "admin@example.com", true, "Admin" });

            migrationBuilder.InsertData(
                table: "Channels",
                columns: new[] { "Id", "CreatedAt", "Name", "OwnerId", "Type" },
                values: new object[] { -1, new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223), "general", -1, "public" });

            migrationBuilder.InsertData(
                table: "ChannelMemberships",
                columns: new[] { "ChannelId", "UserId", "IsMuted", "JoinedAt" },
                values: new object[] { -1, -1, false, new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223) });

            migrationBuilder.CreateIndex(
                name: "IX_ChannelMemberships_UserId",
                table: "ChannelMemberships",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Channels_Name",
                table: "Channels",
                column: "Name");

            migrationBuilder.CreateIndex(
                name: "IX_Channels_OwnerId",
                table: "Channels",
                column: "OwnerId");

            migrationBuilder.CreateIndex(
                name: "IX_MessageReactions_MessageId",
                table: "MessageReactions",
                column: "MessageId");

            migrationBuilder.CreateIndex(
                name: "IX_MessageReactions_UserId",
                table: "MessageReactions",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Messages_ChannelId_CreatedAt",
                table: "Messages",
                columns: new[] { "ChannelId", "CreatedAt" });

            migrationBuilder.CreateIndex(
                name: "IX_Messages_ParentMessageId",
                table: "Messages",
                column: "ParentMessageId");

            migrationBuilder.CreateIndex(
                name: "IX_Messages_UserId",
                table: "Messages",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "ChannelMemberships");

            migrationBuilder.DropTable(
                name: "MessageReactions");

            migrationBuilder.DropTable(
                name: "Messages");

            migrationBuilder.DropTable(
                name: "Channels");

            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
ï»¿// <auto-generated />
using System;
using GauntletSlack3.Api.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace GauntletSlack3.Api.Migrations
{
    [DbContext(typeof(SlackDbContext))]
    partial class SlackDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("OwnerId")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Name");

                    b.HasIndex("OwnerId");

                    b.ToTable("Channels");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            CreatedAt = new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051),
                            Name = "general",
                            OwnerId = -1,
                            Type = "public"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.Property<bool>("IsMuted")
                        .HasColumnType("bit");

                    b.Property<DateTime>("JoinedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("ChannelId", "UserId");

                    b.HasIndex("UserId");

                    b.ToTable("ChannelMemberships");

                    b.HasData(
                        new
                        {
                            ChannelId = -1,
                            UserId = -1,
                            IsMuted = false,
                            JoinedAt = new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051)
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<int?>("ParentMessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ParentMessageId");

                    b.HasIndex("UserId");

                    b.HasIndex("ChannelId", "CreatedAt");

                    b.ToTable("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Emoji")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("MessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MessageId");

                    b.HasIndex("UserId");

                    b.ToTable("MessageReactions");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<bool>("IsAdmin")
                        .HasColumnType("bit");

                    b.Property<bool>("IsOnline")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            Email = "admin@example.com",
                            IsAdmin = true,
                            IsOnline = false,
                            Name = "Admin"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.User", "Owner")
                        .WithMany("OwnedChannels")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Memberships")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Memberships")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Messages")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.Message", "ParentMessage")
                        .WithMany("Replies")
                        .HasForeignKey("ParentMessageId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Messages")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("ParentMessage");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Message", "Message")
                        .WithMany("Reactions")
                        .HasForeignKey("MessageId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Message");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Navigation("Reactions");

                    b.Navigation("Replies");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");

                    b.Navigation("OwnedChannels");
                });
#pragma warning restore 612, 618
        }
    }
}
ï»¿// <auto-generated />
using System;
using GauntletSlack3.Api.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace GauntletSlack3.Api.Migrations
{
    [DbContext(typeof(SlackDbContext))]
    [Migration("20250110083453_AddUserOnlineStatus")]
    partial class AddUserOnlineStatus
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("OwnerId")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Name");

                    b.HasIndex("OwnerId");

                    b.ToTable("Channels");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            CreatedAt = new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051),
                            Name = "general",
                            OwnerId = -1,
                            Type = "public"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.Property<bool>("IsMuted")
                        .HasColumnType("bit");

                    b.Property<DateTime>("JoinedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("ChannelId", "UserId");

                    b.HasIndex("UserId");

                    b.ToTable("ChannelMemberships");

                    b.HasData(
                        new
                        {
                            ChannelId = -1,
                            UserId = -1,
                            IsMuted = false,
                            JoinedAt = new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051)
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<int?>("ParentMessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ParentMessageId");

                    b.HasIndex("UserId");

                    b.HasIndex("ChannelId", "CreatedAt");

                    b.ToTable("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Emoji")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("MessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MessageId");

                    b.HasIndex("UserId");

                    b.ToTable("MessageReactions");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<bool>("IsAdmin")
                        .HasColumnType("bit");

                    b.Property<bool>("IsOnline")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            Email = "admin@example.com",
                            IsAdmin = true,
                            IsOnline = false,
                            Name = "Admin"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.User", "Owner")
                        .WithMany("OwnedChannels")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Memberships")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Memberships")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Messages")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.Message", "ParentMessage")
                        .WithMany("Replies")
                        .HasForeignKey("ParentMessageId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Messages")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("ParentMessage");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Message", "Message")
                        .WithMany("Reactions")
                        .HasForeignKey("MessageId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Message");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Navigation("Reactions");

                    b.Navigation("Replies");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");

                    b.Navigation("OwnedChannels");
                });
#pragma warning restore 612, 618
        }
    }
}
ï»¿// <auto-generated />
using System;
using GauntletSlack3.Api.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace GauntletSlack3.Api.Migrations
{
    [DbContext(typeof(SlackDbContext))]
    [Migration("20250110003356_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("OwnerId")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Name");

                    b.HasIndex("OwnerId");

                    b.ToTable("Channels");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            CreatedAt = new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223),
                            Name = "general",
                            OwnerId = -1,
                            Type = "public"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.Property<bool>("IsMuted")
                        .HasColumnType("bit");

                    b.Property<DateTime>("JoinedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("ChannelId", "UserId");

                    b.HasIndex("UserId");

                    b.ToTable("ChannelMemberships");

                    b.HasData(
                        new
                        {
                            ChannelId = -1,
                            UserId = -1,
                            IsMuted = false,
                            JoinedAt = new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223)
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("ChannelId")
                        .HasColumnType("int");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<int?>("ParentMessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("ParentMessageId");

                    b.HasIndex("UserId");

                    b.HasIndex("ChannelId", "CreatedAt");

                    b.ToTable("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Emoji")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("MessageId")
                        .HasColumnType("int");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MessageId");

                    b.HasIndex("UserId");

                    b.ToTable("MessageReactions");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<bool>("IsAdmin")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = -1,
                            Email = "admin@example.com",
                            IsAdmin = true,
                            Name = "Admin"
                        });
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.User", "Owner")
                        .WithMany("OwnedChannels")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.ChannelMembership", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Memberships")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Memberships")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Channel", "Channel")
                        .WithMany("Messages")
                        .HasForeignKey("ChannelId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.Message", "ParentMessage")
                        .WithMany("Replies")
                        .HasForeignKey("ParentMessageId")
                        .OnDelete(DeleteBehavior.Restrict);

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany("Messages")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Channel");

                    b.Navigation("ParentMessage");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.MessageReaction", b =>
                {
                    b.HasOne("GauntletSlack3.Shared.Models.Message", "Message")
                        .WithMany("Reactions")
                        .HasForeignKey("MessageId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("GauntletSlack3.Shared.Models.User", "User")
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Message");

                    b.Navigation("User");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Channel", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.Message", b =>
                {
                    b.Navigation("Reactions");

                    b.Navigation("Replies");
                });

            modelBuilder.Entity("GauntletSlack3.Shared.Models.User", b =>
                {
                    b.Navigation("Memberships");

                    b.Navigation("Messages");

                    b.Navigation("OwnedChannels");
                });
#pragma warning restore 612, 618
        }
    }
}
ï»¿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace GauntletSlack3.Api.Migrations
{
    /// <inheritdoc />
    public partial class AddUserOnlineStatus : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<bool>(
                name: "IsOnline",
                table: "Users",
                type: "bit",
                nullable: false,
                defaultValue: false);

            migrationBuilder.UpdateData(
                table: "ChannelMemberships",
                keyColumns: new[] { "ChannelId", "UserId" },
                keyValues: new object[] { -1, -1 },
                column: "JoinedAt",
                value: new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051));

            migrationBuilder.UpdateData(
                table: "Channels",
                keyColumn: "Id",
                keyValue: -1,
                column: "CreatedAt",
                value: new DateTime(2025, 1, 10, 8, 34, 49, 754, DateTimeKind.Utc).AddTicks(1051));

            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: -1,
                column: "IsOnline",
                value: false);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "IsOnline",
                table: "Users");

            migrationBuilder.UpdateData(
                table: "ChannelMemberships",
                keyColumns: new[] { "ChannelId", "UserId" },
                keyValues: new object[] { -1, -1 },
                column: "JoinedAt",
                value: new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223));

            migrationBuilder.UpdateData(
                table: "Channels",
                keyColumn: "Id",
                keyValue: -1,
                column: "CreatedAt",
                value: new DateTime(2025, 1, 10, 0, 33, 56, 391, DateTimeKind.Utc).AddTicks(6223));
        }
    }
}
{
    "ConnectionStrings": {
      "DefaultConnection": "Server=tcp:mccorkel.database.windows.net,1433;Initial Catalog=mccorkel-gauntlet-slack3-db;Persist Security Info=False;User ID=mccorkeladmin;Password=c00kiemonster!;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
    },
    "Logging": {
      "LogLevel": {
        "Default": "Information",
        "Microsoft.AspNetCore": "Warning"
      }
    },
    "AllowedHosts": "*"
  }{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
{
    "ConnectionStrings": {
      "DefaultConnection": "Server=tcp:mccorkel.database.windows.net,1433;Initial Catalog=mccorkel-gauntlet-slack3-db;Persist Security Info=False;User ID=mccorkeladmin;Password=c00kiemonster!;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
    },
    "Logging": {
      "LogLevel": {
        "Default": "Information",
        "Microsoft.AspNetCore": "Warning"
      }
    },
    "AllowedHosts": "*"
  }using Microsoft.AspNetCore.SignalR;

namespace GauntletSlack3.Api.Hubs
{
    public class UserStatusHub : Hub
    {
        private readonly ILogger<UserStatusHub> _logger;

        public UserStatusHub(ILogger<UserStatusHub> logger)
        {
            _logger = logger;
        }

        public async Task OnConnected(string userId)
        {
            await Groups.AddToGroupAsync(Context.ConnectionId, userId);
            _logger.LogInformation("User {UserId} connected", userId);
            await Clients.Others.SendAsync("UserJoined", userId);
        }

        public async Task UpdateStatus(string userId, bool isOnline)
        {
            _logger.LogInformation("User {UserId} status changed to {IsOnline}", userId, isOnline);
            await Clients.Others.SendAsync("UserStatusChanged", userId, isOnline);
        }

        public async Task OnDisconnected(string userId)
        {
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, userId);
            _logger.LogInformation("User {UserId} disconnected", userId);
            await Clients.All.SendAsync("UserStatusChanged", userId, false);
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            _logger.LogInformation("Connection {ConnectionId} disconnected", Context.ConnectionId);
            await base.OnDisconnectedAsync(exception);
        }
    }
} {
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using GauntletSlack3.Shared.Models;
using GauntletSlack3.Api.Data;
using Microsoft.Extensions.Logging;

namespace GauntletSlack3.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class MessagesController : ControllerBase
    {
        private readonly SlackDbContext _context;
        private readonly ILogger<MessagesController> _logger;

        public MessagesController(SlackDbContext context, ILogger<MessagesController> logger)
        {
            _context = context;
            _logger = logger;
        }

        // POST: api/messages/channel/{channelId}
        [HttpPost("channel/{channelId}")]
        public async Task<ActionResult<Message>> PostMessage(int channelId, [FromBody] CreateMessageRequest request)
        {
            try
            {
                _logger.LogInformation("Creating message in channel {ChannelId} from user {UserId} with content: {Content}", 
                    channelId, request.UserId, request.Content);

                if (request == null)
                {
                    _logger.LogWarning("Request body is null");
                    return BadRequest("Request body cannot be null");
                }

                if (string.IsNullOrWhiteSpace(request.Content))
                {
                    _logger.LogWarning("Message content is empty");
                    return BadRequest("Message content cannot be empty");
                }

                var channel = await _context.Channels
                    .Include(c => c.Memberships)
                    .FirstOrDefaultAsync(c => c.Id == channelId);

                if (channel == null)
                {
                    _logger.LogWarning("Channel {ChannelId} not found", channelId);
                    return NotFound($"Channel {channelId} not found");
                }

                // Check if user is a member of the channel
                var isMember = await _context.ChannelMemberships
                    .AnyAsync(cm => cm.ChannelId == channelId && cm.UserId == request.UserId);

                if (!isMember)
                {
                    _logger.LogWarning("User {UserId} is not a member of channel {ChannelId}", request.UserId, channelId);
                    return BadRequest("User is not a member of this channel");
                }

                var message = new Message
                {
                    Content = request.Content,
                    UserId = request.UserId,
                    ChannelId = channelId,
                    CreatedAt = DateTime.UtcNow
                };

                _context.Messages.Add(message);
                await _context.SaveChangesAsync();

                // Load the user for the response
                await _context.Entry(message)
                    .Reference(m => m.User)
                    .LoadAsync();

                return message;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating message in channel {ChannelId}", channelId);
                return StatusCode(500, "An error occurred while creating the message");
            }
        }

        // GET: api/messages/channel/{channelId}
        [HttpGet("channel/{channelId}")]
        public async Task<ActionResult<List<Message>>> GetChannelMessages(int channelId)
        {
            var messages = await _context.Messages
                .Where(m => m.ChannelId == channelId)
                .Include(m => m.User)
                .OrderByDescending(m => m.CreatedAt)
                .ToListAsync();

            return Ok(messages);
        }

        // GET: api/messages/{id}
        [HttpGet("{id}")]
        public async Task<ActionResult<Message>> GetMessage(int id)
        {
            var message = await _context.Messages
                .Include(m => m.User)
                .FirstOrDefaultAsync(m => m.Id == id);

            if (message == null)
            {
                return NotFound();
            }

            return Ok(message);
        }

        // DELETE: api/messages/{id}
        [HttpDelete("{id}")]
        public async Task<ActionResult> DeleteMessage(int id)
        {
            var message = await _context.Messages.FindAsync(id);
            if (message == null)
            {
                return NotFound();
            }

            _context.Messages.Remove(message);
            await _context.SaveChangesAsync();
            return Ok();
        }

        // POST: api/messages/{messageId}/reply
        [HttpPost("{messageId}/reply")]
        public async Task<ActionResult<Message>> PostReply(int messageId, [FromBody] CreateMessageRequest request)
        {
            try
            {
                _logger.LogInformation("Creating reply to message {MessageId}", messageId);

                var parentMessage = await _context.Messages
                    .Include(m => m.Channel)
                    .ThenInclude(c => c.Memberships)
                    .FirstOrDefaultAsync(m => m.Id == messageId);

                if (parentMessage == null)
                {
                    _logger.LogWarning("Parent message {MessageId} not found", messageId);
                    return NotFound($"Message {messageId} not found");
                }

                // Check if user is a member of the channel
                var isMember = parentMessage.Channel?.Memberships
                    .Any(m => m.UserId == request.UserId) ?? false;

                if (!isMember)
                {
                    _logger.LogWarning("User {UserId} is not a member of the channel", request.UserId);
                    return BadRequest("User is not a member of this channel");
                }

                var reply = new Message
                {
                    Content = request.Content,
                    UserId = request.UserId,
                    ChannelId = parentMessage.ChannelId,
                    ParentMessageId = messageId,
                    CreatedAt = DateTime.UtcNow
                };

                _context.Messages.Add(reply);
                await _context.SaveChangesAsync();

                // Load related data for response
                await _context.Entry(reply)
                    .Reference(m => m.User)
                    .LoadAsync();

                return Ok(reply);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating reply to message {MessageId}", messageId);
                return StatusCode(500, "An error occurred while creating the reply");
            }
        }

        // POST: api/messages/{messageId}/reactions
        [HttpPost("{messageId}/reactions")]
        public async Task<ActionResult> AddReaction(int messageId, [FromBody] AddReactionRequest request)
        {
            try
            {
                _logger.LogInformation("Adding reaction to message {MessageId}", messageId);

                var message = await _context.Messages
                    .Include(m => m.Channel)
                    .ThenInclude(c => c.Memberships)
                    .FirstOrDefaultAsync(m => m.Id == messageId);

                if (message == null)
                {
                    return NotFound($"Message {messageId} not found");
                }

                // Check if user is a member of the channel
                var isMember = message.Channel?.Memberships
                    .Any(m => m.UserId == request.UserId) ?? false;

                if (!isMember)
                {
                    return BadRequest("User is not a member of this channel");
                }

                var reaction = new MessageReaction
                {
                    MessageId = messageId,
                    UserId = request.UserId,
                    Emoji = request.Emoji,
                    CreatedAt = DateTime.UtcNow
                };

                _context.MessageReactions.Add(reaction);
                await _context.SaveChangesAsync();

                return Ok();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding reaction to message {MessageId}", messageId);
                return StatusCode(500, "An error occurred while adding the reaction");
            }
        }

        // DELETE: api/messages/{messageId}/reactions
        [HttpDelete("{messageId}/reactions")]
        public async Task<ActionResult> RemoveReaction(int messageId, [FromQuery] int userId, [FromQuery] string emoji)
        {
            try
            {
                var reaction = await _context.MessageReactions
                    .FirstOrDefaultAsync(r => 
                        r.MessageId == messageId && 
                        r.UserId == userId && 
                        r.Emoji == emoji);

                if (reaction == null)
                {
                    return NotFound("Reaction not found");
                }

                _context.MessageReactions.Remove(reaction);
                await _context.SaveChangesAsync();

                return Ok();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error removing reaction from message {MessageId}", messageId);
                return StatusCode(500, "An error occurred while removing the reaction");
            }
        }

        public class CreateMessageRequest
        {
            public string Content { get; set; } = string.Empty;
            public int UserId { get; set; }
        }

        public class AddReactionRequest
        {
            public int UserId { get; set; }
            public string Emoji { get; set; } = string.Empty;
        }
    }
} using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using GauntletSlack3.Shared.Models;
using GauntletSlack3.Api.Data;
using Microsoft.Extensions.Logging;

namespace GauntletSlack3.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ChannelsController : ControllerBase
    {
        private readonly SlackDbContext _context;
        private readonly ILogger<ChannelsController> _logger;

        public ChannelsController(SlackDbContext context, ILogger<ChannelsController> logger)
        {
            _context = context;
            _logger = logger;
        }

        [HttpGet]
        public async Task<ActionResult<List<Channel>>> GetChannels([FromQuery] int userId)
        {
            try
            {
                _logger.LogInformation("Getting channels for user {UserId}", userId);
                var channels = await _context.Channels
                    .Include(c => c.Memberships)
                    .Include(c => c.Messages)
                    .ThenInclude(m => m.User)
                    .Where(c => c.Memberships.Any(m => m.UserId == userId))
                    .ToListAsync();
                return channels;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting channels for user {UserId}", userId);
                return StatusCode(500, "An error occurred while retrieving channels");
            }
        }

        [HttpGet("user/{userId}")]
        public async Task<ActionResult<List<Channel>>> GetUserChannels(int userId)
        {
            Console.WriteLine($"API: Getting channels for user {userId}");
            
            // Check if user exists
            var user = await _context.Users.FindAsync(userId);
            Console.WriteLine($"API: User exists: {user != null}");

            // Check all channels
            var allChannels = await _context.Channels.ToListAsync();
            Console.WriteLine($"API: Total channels in database: {allChannels.Count}");

            // Check memberships
            var memberships = await _context.ChannelMemberships
                .Where(m => m.UserId == userId)
                .ToListAsync();
            Console.WriteLine($"API: User memberships found: {memberships.Count}");

            var channels = await _context.Channels
                .Include(c => c.Memberships)
                .Include(c => c.Messages)
                .ThenInclude(m => m.User)
                .Where(c => c.Memberships.Any(m => m.UserId == userId))
                .ToListAsync();
            
            Console.WriteLine($"API: Found {channels.Count} channels for user {userId}");
            foreach (var channel in channels)
            {
                Console.WriteLine($"API: Channel {channel.Id}: {channel.Name} with {channel.Memberships?.Count ?? 0} members");
            }
            
            return channels;
        }

        [HttpPost]
        public async Task<ActionResult<Channel>> CreateChannel([FromBody] CreateChannelRequest request)
        {
            var channel = new Channel
            {
                Name = request.Name,
                Type = request.Type,
                CreatedAt = DateTime.UtcNow,
                OwnerId = request.UserId
            };

            _context.Channels.Add(channel);
            await _context.SaveChangesAsync();

            _context.ChannelMemberships.Add(new ChannelMembership
            {
                ChannelId = channel.Id,
                UserId = request.UserId,
                JoinedAt = DateTime.UtcNow,
                IsMuted = false
            });

            await _context.SaveChangesAsync();

            return await _context.Channels
                .Include(c => c.Memberships)
                .Include(c => c.Messages)
                .ThenInclude(m => m.User)
                .FirstAsync(c => c.Id == channel.Id);
        }

        [HttpGet("{channelId}/members")]
        public async Task<ActionResult<List<User>>> GetChannelMembers(int channelId)
        {
            return await _context.Users
                .Where(u => u.Memberships.Any(m => m.ChannelId == channelId))
                .ToListAsync();
        }

        [HttpPost("{channelId}/join")]
        public async Task<IActionResult> JoinChannel(int channelId, [FromBody] int userId)
        {
            try
            {
                // Add logging
                _logger.LogInformation($"Joining channel {channelId} for user {userId}");
                
                var channel = await _context.Channels
                    .Include(c => c.Memberships)
                    .FirstOrDefaultAsync(c => c.Id == channelId);

                if (channel == null)
                {
                    _logger.LogWarning($"Channel {channelId} not found");
                    return NotFound();
                }

                // Check if user is already a member
                if (channel.Memberships?.Any(m => m.UserId == userId) == true)
                {
                    _logger.LogInformation($"User {userId} is already a member of channel {channelId}");
                    return Ok();
                }

                var membership = new ChannelMembership
                {
                    ChannelId = channelId,
                    UserId = userId,
                    JoinedAt = DateTime.UtcNow
                };

                _context.ChannelMemberships.Add(membership);
                await _context.SaveChangesAsync();

                return Ok();
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error joining channel: {ex.Message}");
                return BadRequest(ex.Message);
            }
        }

        [HttpPost("{channelId}/leave")]
        public async Task<ActionResult> LeaveChannel(int channelId, [FromBody] int userId)
        {
            try
            {
                _logger.LogInformation("User {UserId} leaving channel {ChannelId}", userId, channelId);

                var membership = await _context.ChannelMemberships
                    .FirstOrDefaultAsync(m => m.ChannelId == channelId && m.UserId == userId);

                if (membership == null)
                {
                    _logger.LogWarning("Membership not found for user {UserId} in channel {ChannelId}", userId, channelId);
                    return NotFound("User is not a member of this channel");
                }

                _context.ChannelMemberships.Remove(membership);
                await _context.SaveChangesAsync();

                return Ok();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error removing user {UserId} from channel {ChannelId}", userId, channelId);
                return StatusCode(500, "An error occurred while leaving the channel");
            }
        }
    }

    public class CreateChannelRequest
    {
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public int UserId { get; set; }
    }
} using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System;
using System.Threading.Tasks;
using GauntletSlack3.Shared.Models;
using GauntletSlack3.Api.Data;
using Microsoft.Extensions.Logging;
using Microsoft.AspNetCore.SignalR;

namespace GauntletSlack3.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class UsersController : ControllerBase
    {
        private readonly SlackDbContext _context;
        private readonly ILogger<UsersController> _logger;

        public UsersController(
            SlackDbContext context, 
            ILogger<UsersController> logger)
        {
            _context = context;
            _logger = logger;
        }

        [HttpGet]
        public async Task<ActionResult<List<User>>> GetUsers()
        {
            try
            {
                return await _context.Users
                    .Include(u => u.Memberships)
                    .ToListAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting users");
                return StatusCode(500, "An error occurred while retrieving users");
            }
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<User>> GetUser(int id)
        {
            var user = await _context.Users
                .Include(u => u.Memberships)
                .FirstOrDefaultAsync(u => u.Id == id);

            if (user == null)
            {
                return NotFound();
            }

            return user;
        }

        [HttpPost("getorcreate")]
        public async Task<ActionResult<int>> GetOrCreateUser([FromBody] UserInfo userInfo)
        {
            var user = await _context.Users
                .FirstOrDefaultAsync(u => u.Email == userInfo.Email);

            if (user == null)
            {
                user = new User
                {
                    Email = userInfo.Email,
                    Name = userInfo.Name,
                    IsAdmin = false
                };
                _context.Users.Add(user);
                await _context.SaveChangesAsync();
            }

            return user.Id;
        }

        [HttpPut("{userId}/status")]
        public async Task<IActionResult> UpdateStatus(int userId, [FromBody] UpdateStatusRequest request)
        {
            try
            {
                var user = await _context.Users.FindAsync(userId);
                if (user == null)
                {
                    return NotFound();
                }

                user.IsOnline = request.IsOnline;
                await _context.SaveChangesAsync();

                return Ok();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating status for user {UserId}", userId);
                return StatusCode(500, "An error occurred while updating user status");
            }
        }
    }

    public class UserInfo
    {
        public string Email { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
    }

    public class UpdateStatusRequest
    {
        public bool IsOnline { get; set; }
    }
} using Microsoft.EntityFrameworkCore;
using GauntletSlack3.Shared.Models;

namespace GauntletSlack3.Api.Data;

public class SlackDbContext : DbContext
{
    public SlackDbContext(DbContextOptions<SlackDbContext> options)
        : base(options)
    {
    }

    public DbSet<Channel> Channels { get; set; }
    public DbSet<Message> Messages { get; set; }
    public DbSet<User> Users { get; set; }
    public DbSet<ChannelMembership> ChannelMemberships { get; set; }
    public DbSet<MessageReaction> MessageReactions { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure User
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired();
            entity.Property(e => e.Email).IsRequired();
            entity.Property(e => e.IsAdmin).IsRequired();

            // Index for email lookups
            entity.HasIndex(e => e.Email).IsUnique();

            entity.HasMany(u => u.Memberships)
                .WithOne(cm => cm.User)
                .HasForeignKey(cm => cm.UserId);
        });

        // Configure Channel
        modelBuilder.Entity<Channel>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired();
            entity.Property(e => e.Type).IsRequired();
            entity.Property(e => e.OwnerId).IsRequired();
            entity.Property(e => e.CreatedAt).IsRequired();

            // Channel owner relationship
            entity.HasOne(e => e.Owner)
                .WithMany(e => e.OwnedChannels)
                .HasForeignKey(e => e.OwnerId)
                .OnDelete(DeleteBehavior.Restrict);

            // Index for channel name lookups
            entity.HasIndex(e => e.Name);

            // Update this to use Memberships instead of ChannelUsers
            entity.HasMany(e => e.Memberships)
                .WithOne(e => e.Channel)
                .HasForeignKey(e => e.ChannelId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Configure Message
        modelBuilder.Entity<Message>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Content).IsRequired();
            entity.Property(e => e.UserId).IsRequired();
            entity.Property(e => e.CreatedAt).IsRequired();

            // Parent message relationship
            entity.HasOne(e => e.ParentMessage)
                .WithMany(e => e.Replies)
                .HasForeignKey(e => e.ParentMessageId)
                .OnDelete(DeleteBehavior.Restrict);

            // Message sender relationship
            entity.HasOne(e => e.User)
                .WithMany(e => e.Messages)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Restrict);

            // Message channel relationship
            entity.HasOne(e => e.Channel)
                .WithMany(e => e.Messages)
                .HasForeignKey(e => e.ChannelId)
                .OnDelete(DeleteBehavior.Cascade);

            // Index for channel message lookups
            entity.HasIndex(e => new { e.ChannelId, e.CreatedAt });
            entity.HasIndex(e => e.ParentMessageId);
        });

        // Configure MessageReaction
        modelBuilder.Entity<MessageReaction>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Emoji).IsRequired();
            entity.Property(e => e.CreatedAt).IsRequired();

            entity.HasOne(e => e.Message)
                .WithMany(e => e.Reactions)
                .HasForeignKey(e => e.MessageId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany()
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Restrict);

            entity.HasIndex(e => e.MessageId);
            entity.HasIndex(e => e.UserId);
        });

        // Configure ChannelMembership
        modelBuilder.Entity<ChannelMembership>(entity =>
        {
            entity.HasKey(e => new { e.ChannelId, e.UserId });
            entity.Property(e => e.JoinedAt).IsRequired();

            // Channel membership relationships
            entity.HasOne(e => e.Channel)
                .WithMany(e => e.Memberships)
                .HasForeignKey(e => e.ChannelId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.User)
                .WithMany(e => e.Memberships)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            // Index for user membership lookups
            entity.HasIndex(e => e.UserId);
        });

        // Seed initial data
        SeedData(modelBuilder);
    }

    private void SeedData(ModelBuilder modelBuilder)
    {
        var adminId = -1;
        var now = DateTime.UtcNow;

        // Seed admin user
        modelBuilder.Entity<User>().HasData(
            new User
            {
                Id = adminId,
                Name = "Admin",
                Email = "admin@example.com",
                IsAdmin = true
            }
        );

        // Seed general channel
        modelBuilder.Entity<Channel>().HasData(
            new Channel
            {
                Id = -1,
                Name = "general",
                Type = "public",
                OwnerId = adminId,
                CreatedAt = now
            }
        );

        // Seed admin membership in general channel
        modelBuilder.Entity<ChannelMembership>().HasData(
            new ChannelMembership
            {
                ChannelId = -1,
                UserId = adminId,
                JoinedAt = now,
                IsMuted = false
            }
        );
    }
} using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Hosting;

public class BackgroundMessageProcessor : BackgroundService
{
    private readonly ILogger<BackgroundMessageProcessor> _logger;

    public BackgroundMessageProcessor(ILogger<BackgroundMessageProcessor> logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await ProcessMessageQueueAsync();
            await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);
        }
    }

    private async Task ProcessMessageQueueAsync()
    {
        try
        {
            // Add your message processing logic here
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing message queue");
        }
    }
} using Microsoft.EntityFrameworkCore;
using GauntletSlack3.Api.Data;
using Microsoft.AspNetCore.Builder;
using Microsoft.VisualStudio.Web.BrowserLink;
using Microsoft.AspNetCore.SignalR;
using GauntletSlack3.Api.Hubs;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.OpenApi.Models;
using Microsoft.ApplicationInsights.Extensibility;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles;
    });
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "GauntletSlack3 API",
        Version = "v1",
        Description = "API for GauntletSlack3 chat application"
    });
    
    options.AddSecurityDefinition("oauth2", new OpenApiSecurityScheme
    {
        Type = SecuritySchemeType.OAuth2,
        Flows = new OpenApiOAuthFlows
        {
            AuthorizationCode = new OpenApiOAuthFlow
            {
                AuthorizationUrl = new Uri("https://login.microsoftonline.com/common/oauth2/v2.0/authorize"),
                TokenUrl = new Uri("https://login.microsoftonline.com/common/oauth2/v2.0/token")
            }
        }
    });
});

// Add SignalR
builder.Services.AddSignalR();

// Add CORS for Blazor WebAssembly
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(builder =>
    {
        builder.WithOrigins("https://localhost:7229")
               .AllowAnyMethod()
               .AllowAnyHeader()
               .AllowCredentials();
    });
});

// Add DbContext
builder.Services.AddDbContext<SlackDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddRateLimiter(options =>
{
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>
        RateLimitPartition.GetFixedWindowLimiter(
            partitionKey: context.User.Identity?.Name ?? context.Request.Headers.Host.ToString(),
            factory: partition => new FixedWindowRateLimiterOptions
            {
                AutoReplenishment = true,
                PermitLimit = 100,
                Window = TimeSpan.FromMinutes(1)
            }));
});

builder.Services.AddApplicationInsightsTelemetry();

builder.Services.AddSerilog(configuration => 
{
    configuration
        .WriteTo.Console()
        .WriteTo.ApplicationInsights(new TelemetryConfiguration 
        { 
            InstrumentationKey = builder.Configuration["ApplicationInsights:InstrumentationKey"] 
        }, TelemetryConverter.Traces);
});

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseBrowserLink();
} else {
    app.UseHttpsRedirection();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();

app.UseCors();
app.UseAuthorization();
app.MapControllers();
app.MapHub<UserStatusHub>("/hubs/userstatus");

app.Run(); <Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RuntimeIdentifier>browser-wasm</RuntimeIdentifier>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Azure.Identity" Version="1.13.1" />
    <PackageReference Include="Microsoft.AspNetCore.Components.Authorization" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="9.0.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Core" Version="2.2.5" />
    <PackageReference Include="Microsoft.Authentication.WebAssembly.Msal" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\GauntletSlack3.Shared\GauntletSlack3.Shared.csproj" />
  </ItemGroup>

</Project>
// <auto-generated/>
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("GauntletSlack3")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+184625228a7e069bf2fe10e13b324bca60bdf1e9")]
[assembly: System.Reflection.AssemblyProductAttribute("GauntletSlack3")]
[assembly: System.Reflection.AssemblyTitleAttribute("GauntletSlack3")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

{
    "AzureAd": {
      "Authority": "https://login.microsoftonline.com/94d494f5-5b3e-48e3-8a27-45e7da636b78/",
      "ClientId": "a54a881c-a232-4642-937c-81f5c2507f8e",
      "ValidateAuthority": true,
      "DefaultScope": "openid profile email"
    },
    "ApiBaseUrl": "http://localhost:5256",
    "ConnectionStrings": {
      "WebPubSub": "Endpoint=https://mccorkel-gauntlet-slack3-ps.webpubsub.azure.com;AccessKey=BPXyrgQ3Q1ozfkn2LxzHuCBNy8IZQFVdt2Pa0mYa7GpabjpnyTV9JQQJ99BAAC8vTInXJ3w3AAAAAWPSsEw6;Version=1.0;"
    }
}ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GauntletSlack3", "GauntletSlack3.csproj", "{587B4D78-ACF2-4512-8B00-EBC156BBB7BA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GauntletSlack3.Api", "..\GauntletSlack3.Api\GauntletSlack3.Api.csproj", "{5E929F23-A7CB-4F4D-A559-EBD2CC15D477}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GauntletSlack3.Shared", "..\GauntletSlack3.Shared\GauntletSlack3.Shared.csproj", "{010FB5EF-C570-47F5-A652-EC29E687ED60}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{3867A19D-85B6-4285-9DB8-F9D1049B6B06}"
	ProjectSection(SolutionItems) = preProject
		..\.cursorrules = ..\.cursorrules
		..\Documentation\features.md = ..\Documentation\features.md
		..\Documentation\implementation.md = ..\Documentation\implementation.md
		..\Documentation\project-overview.md = ..\Documentation\project-overview.md
		..\Documentation\project-structure.md = ..\Documentation\project-structure.md
		..\Documentation\requirements.md = ..\Documentation\requirements.md
		..\Documentation\tech-stack.md = ..\Documentation\tech-stack.md
		..\Documentation\user-flow.md = ..\Documentation\user-flow.md
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Scripts", "Scripts", "{27884452-21DD-40A0-9858-A34972A6DF66}"
	ProjectSection(SolutionItems) = preProject
		..\Scripts\recreate-db.ps1 = ..\Scripts\recreate-db.ps1
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{587B4D78-ACF2-4512-8B00-EBC156BBB7BA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{587B4D78-ACF2-4512-8B00-EBC156BBB7BA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{587B4D78-ACF2-4512-8B00-EBC156BBB7BA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{587B4D78-ACF2-4512-8B00-EBC156BBB7BA}.Release|Any CPU.Build.0 = Release|Any CPU
		{5E929F23-A7CB-4F4D-A559-EBD2CC15D477}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5E929F23-A7CB-4F4D-A559-EBD2CC15D477}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5E929F23-A7CB-4F4D-A559-EBD2CC15D477}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5E929F23-A7CB-4F4D-A559-EBD2CC15D477}.Release|Any CPU.Build.0 = Release|Any CPU
		{010FB5EF-C570-47F5-A652-EC29E687ED60}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{010FB5EF-C570-47F5-A652-EC29E687ED60}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{010FB5EF-C570-47F5-A652-EC29E687ED60}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{010FB5EF-C570-47F5-A652-EC29E687ED60}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Net.Http.Json;
using GauntletSlack3.Shared.Models;

public class SlackService
{
    private readonly HttpClient _httpClient;

    public SlackService(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task<List<Channel>> GetChannelsForUserAsync(string userId)
    {
        return await _httpClient.GetFromJsonAsync<List<Channel>>($"api/channels?userId={userId}") ?? new List<Channel>();
    }

    public async Task<List<Message>> GetChannelMessagesAsync(int channelId)
    {
        return await _httpClient.GetFromJsonAsync<List<Message>>($"api/channels/{channelId}/messages") ?? new List<Message>();
    }

    public async Task<Message> AddMessageAsync(Message message)
    {
        var response = await _httpClient.PostAsJsonAsync("api/messages", message);
        return await response.Content.ReadFromJsonAsync<Message>() ?? message;
    }

    public async Task<bool> JoinChannelAsync(int userId, string userName, int channelId)
    {
        var channelUser = new ChannelUser
        {
            ChannelId = channelId,
            UserId = userId
        };

        var response = await _httpClient.PostAsJsonAsync($"api/channels/{channelId}/join", channelUser);
        return response.IsSuccessStatusCode;
    }
} using Microsoft.AspNetCore.Components.Authorization;
using System.Net.Http.Json;
using GauntletSlack3.Services.Interfaces;
using GauntletSlack3.Shared.Models;

namespace GauntletSlack3.Services;

public class UserService : IUserService
{
    private readonly HttpClient _http;
    private readonly ILogger<UserService> _logger;
    private readonly AuthenticationStateProvider _authStateProvider;
    private int? _currentUserId;

    public UserService(HttpClient http, ILogger<UserService> logger, AuthenticationStateProvider authStateProvider)
    {
        _http = http;
        _logger = logger;
        _authStateProvider = authStateProvider;
    }

    public async Task<int> GetOrCreateUserAsync(string email, string name)
    {
        try
        {
            var response = await _http.PostAsJsonAsync("api/Users/getorcreate", new { Email = email, Name = name });
            if (response.IsSuccessStatusCode)
            {
                return await response.Content.ReadFromJsonAsync<int>();
            }
            _logger.LogError("Failed to create user. Status: {StatusCode}", response.StatusCode);
            throw new Exception("Failed to get or create user");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GetOrCreateUserAsync for {Email}", email);
            throw;
        }
    }

    public async Task<List<User>> GetUsersAsync()
    {
        try
        {
            var users = await _http.GetFromJsonAsync<List<User>>("api/users");
            return users ?? new List<User>();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching users");
            throw;
        }
    }

    public async Task<User?> GetUserAsync(int userId)
    {
        try
        {
            return await _http.GetFromJsonAsync<User>($"api/users/{userId}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching user {UserId}", userId);
            return null;
        }
    }

    public async Task<bool> UpdateUserStatusAsync(int userId, bool isOnline)
    {
        try
        {
            _logger.LogInformation("Updating status for user {UserId} to {Status}", userId, isOnline ? "online" : "offline");
            var response = await _http.PutAsJsonAsync($"api/users/{userId}/status", new { IsOnline = isOnline });
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating status for user {UserId}", userId);
            return false;
        }
    }

    public async Task<int> GetCurrentUserId()
    {
        if (_currentUserId.HasValue)
            return _currentUserId.Value;

        var authState = await _authStateProvider.GetAuthenticationStateAsync();
        var email = authState.User.FindFirst("preferred_username")?.Value;
        var name = authState.User.FindFirst("name")?.Value;

        if (string.IsNullOrEmpty(email) || string.IsNullOrEmpty(name))
            throw new InvalidOperationException("User is not properly authenticated");

        _currentUserId = await GetOrCreateUserAsync(email, name);
        return _currentUserId.Value;
    }
} using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.Configuration;
using System.Text.Json;
using GauntletSlack3.Services.Interfaces;

namespace GauntletSlack3.Services;

public class RealTimeService : IAsyncDisposable
{
    private HubConnection? _hubConnection;
    private readonly ILogger<RealTimeService> _logger;
    private bool _isConnected;
    private readonly IUserService _userService;
    private readonly HttpClient _httpClient;
    private const int MaxRetries = 3;
    private int _retryCount = 0;

    public event EventHandler<UserStatusChangedEventArgs>? OnUserStatusChanged;
    public event EventHandler<int>? OnUserJoined;
    public event Func<Task>? OnReconnected;
    public event Action<bool>? ConnectionChanged;

    public RealTimeService(IConfiguration config, ILogger<RealTimeService> logger, IUserService userService, HttpClient httpClient)
    {
        _logger = logger;
        _userService = userService;
        _httpClient = httpClient;

        _hubConnection = new HubConnectionBuilder()
            .WithUrl($"{_httpClient.BaseAddress}hubs/userstatus")
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<string, bool>("UserStatusChanged", (userIdStr, isOnline) =>
        {
            if (int.TryParse(userIdStr, out int userId))
            {
                OnUserStatusChanged?.Invoke(this, new UserStatusChangedEventArgs(userId, isOnline));
            }
        });

        _hubConnection.On<string>("UserJoined", (userIdStr) =>
        {
            if (int.TryParse(userIdStr, out int userId))
            {
                OnUserJoined?.Invoke(this, userId);
            }
        });

        _hubConnection.Closed += async (error) =>
        {
            _isConnected = false;
            ConnectionChanged?.Invoke(false);
            _logger.LogWarning(error, "SignalR connection closed");
            await Task.CompletedTask;
        };

        _hubConnection.Reconnected += async (connectionId) =>
        {
            _isConnected = true;
            ConnectionChanged?.Invoke(true);
            _logger.LogInformation("SignalR connection restored");
            if (OnReconnected != null)
            {
                await OnReconnected.Invoke();
            }
        };
    }

    public async Task StartAsync()
    {
        try
        {
            if (_hubConnection == null)
            {
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl($"{_httpClient.BaseAddress}hubs/userstatus")
                    .WithAutomaticReconnect()
                    .Build();

                _hubConnection.On<string, bool>("UserStatusChanged", (userIdStr, isOnline) =>
                {
                    if (int.TryParse(userIdStr, out int userId))
                    {
                        OnUserStatusChanged?.Invoke(this, new UserStatusChangedEventArgs(userId, isOnline));
                    }
                });
            }

            if (_hubConnection.State != HubConnectionState.Connected)
            {
                await _hubConnection.StartAsync();
                _isConnected = true;
                ConnectionChanged?.Invoke(true);
                
                var userId = await _userService.GetCurrentUserId();
                await _hubConnection.SendAsync("OnConnected", userId.ToString());
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error connecting to SignalR hub");
            _isConnected = false;
            ConnectionChanged?.Invoke(false);
            throw;
        }
    }

    public async Task UpdateUserStatusAsync(int userId, bool isOnline)
    {
        if (!_isConnected)
        {
            _logger.LogWarning("Cannot update status: Not connected");
            return;
        }

        try
        {
            await _hubConnection?.SendAsync("UpdateStatus", userId.ToString(), isOnline);
            _logger.LogInformation("Sent status update for user {UserId}: {IsOnline}", userId, isOnline);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to update user status");
            _isConnected = false;
            throw;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.DisposeAsync();
                _isConnected = false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error disposing SignalR connection");
            }
        }
    }
}

public class UserStatusChangedEventArgs : EventArgs
{
    public int UserId { get; }
    public bool IsOnline { get; }

    public UserStatusChangedEventArgs(int userId, bool isOnline)
    {
        UserId = userId;
        IsOnline = isOnline;
    }
} using GauntletSlack3.Services.Interfaces;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;

namespace GauntletSlack3.Services
{
    public class UserStateService : IUserStateService, IAsyncDisposable
    {
        private readonly ILogger<UserStateService> _logger;
        private readonly RealTimeService _realTimeService;
        private readonly IUserService _userService;
        private Dictionary<int, bool> _userStatuses = new();
        private int? _currentUserId;
        public int? CurrentUserId => _currentUserId;
        public event EventHandler? OnUserStatusChanged;
        private bool _isInitialized;

        public UserStateService(
            ILogger<UserStateService> logger, 
            RealTimeService realTimeService,
            IUserService userService)
        {
            _logger = logger;
            _realTimeService = realTimeService;
            _userService = userService;
            _realTimeService.OnUserStatusChanged += HandleUserStatusChanged;
            _realTimeService.OnUserJoined += HandleUserJoined;
            _realTimeService.OnReconnected += HandleReconnected;
        }

        public async Task InitializeAsync()
        {
            if (_isInitialized) return;
            await InitializeUserStatuses();
            _isInitialized = true;
        }

        private void HandleUserStatusChanged(object? sender, UserStatusChangedEventArgs e)
        {
            _userStatuses[e.UserId] = e.IsOnline;
            OnUserStatusChanged?.Invoke(this, EventArgs.Empty);
        }

        public bool IsUserOnline(int userId)
        {
            return _userStatuses.TryGetValue(userId, out bool status) && status;
        }

        public async Task SetUserOnlineStatus(int userId, bool isOnline)
        {
            try
            {
                _userStatuses[userId] = isOnline;
                await _realTimeService.UpdateUserStatusAsync(userId, isOnline);
                OnUserStatusChanged?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error setting user online status");
                throw;
            }
        }

        private async Task HandleReconnected()
        {
            try
            {
                // Refresh all user statuses after reconnection
                var users = await _userService.GetUsersAsync();
                foreach (var user in users)
                {
                    _userStatuses[user.Id] = user.IsOnline;
                }
                OnUserStatusChanged?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error refreshing user statuses after reconnection");
            }
        }

        private async Task InitializeUserStatuses()
        {
            try
            {
                _currentUserId = await _userService.GetCurrentUserId();
                var users = await _userService.GetUsersAsync();
                foreach (var user in users)
                {
                    _userStatuses[user.Id] = user.IsOnline;
                }
                OnUserStatusChanged?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error initializing user statuses");
            }
        }

        private async void HandleUserJoined(object? sender, int userId)
        {
            try
            {
                // Get the new user's status and add them to our tracking
                var users = await _userService.GetUsersAsync();
                var newUser = users.FirstOrDefault(u => u.Id == userId);
                if (newUser != null)
                {
                    _userStatuses[userId] = newUser.IsOnline;
                    OnUserStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error handling new user joined");
            }
        }

        public async ValueTask DisposeAsync()
        {
            _realTimeService.OnUserStatusChanged -= HandleUserStatusChanged;
            _realTimeService.OnUserJoined -= HandleUserJoined;
            _realTimeService.OnReconnected -= HandleReconnected;
            
            // Clear statuses
            _userStatuses.Clear();
        }
    }
} using GauntletSlack3.Services.Interfaces;
using GauntletSlack3.Shared.Models;
using System.Net.Http.Json;
using Microsoft.Extensions.Caching.Memory;

namespace GauntletSlack3.Services
{
    public class MessageService : IMessageService
    {
        private readonly HttpClient _http;
        private readonly ILogger<MessageService> _logger;
        private readonly IMemoryCache _cache;

        public MessageService(HttpClient http, ILogger<MessageService> logger, IMemoryCache cache)
        {
            _http = http;
            _logger = logger;
            _cache = cache;
        }

        public async Task<List<Message>> GetChannelMessagesAsync(int channelId)
        {
            string cacheKey = $"channel_messages_{channelId}";
            if (_cache.TryGetValue(cacheKey, out List<Message> messages))
            {
                return messages;
            }

            try
            {
                messages = await _http.GetFromJsonAsync<List<Message>>($"api/messages/channel/{channelId}");
                _cache.Set(cacheKey, messages, TimeSpan.FromMinutes(5));
                return messages ?? new List<Message>();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error fetching messages for channel {ChannelId}", channelId);
                throw;
            }
        }

        public async Task<Message> SendMessageAsync(int channelId, int userId, string content)
        {
            try
            {
                _logger.LogInformation("Sending message to channel {ChannelId} from user {UserId} with content: {Content}", 
                    channelId, userId, content);

                var response = await _http.PostAsJsonAsync($"api/messages/channel/{channelId}", new
                {
                    UserId = userId,
                    Content = content
                });

                if (response.IsSuccessStatusCode)
                {
                    return await response.Content.ReadFromJsonAsync<Message>()
                        ?? throw new Exception("Failed to deserialize message response");
                }

                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to send message. Status: {StatusCode}, Error: {Error}", 
                    response.StatusCode, errorContent);
                throw new Exception($"Failed to send message: {errorContent}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending message to channel {ChannelId}", channelId);
                throw;
            }
        }

        public async Task<Message?> GetMessageAsync(int messageId)
        {
            try
            {
                _logger.LogInformation("Fetching message {MessageId}", messageId);
                return await _http.GetFromJsonAsync<Message>($"api/messages/{messageId}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error fetching message {MessageId}", messageId);
                return null;
            }
        }

        public async Task<Message> SendReplyAsync(int parentMessageId, int userId, string content)
        {
            try
            {
                _logger.LogInformation("Sending reply to message {MessageId}", parentMessageId);
                var response = await _http.PostAsJsonAsync($"api/messages/{parentMessageId}/reply", new
                {
                    UserId = userId,
                    Content = content
                });

                response.EnsureSuccessStatusCode();
                return await response.Content.ReadFromJsonAsync<Message>()
                    ?? throw new Exception("Failed to deserialize reply");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending reply to message {MessageId}", parentMessageId);
                throw;
            }
        }

        public async Task AddReactionAsync(int messageId, int userId, string emoji)
        {
            try
            {
                _logger.LogInformation("Adding reaction to message {MessageId}", messageId);
                var response = await _http.PostAsJsonAsync($"api/messages/{messageId}/reactions", new
                {
                    UserId = userId,
                    Emoji = emoji
                });
                response.EnsureSuccessStatusCode();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding reaction to message {MessageId}", messageId);
                throw;
            }
        }

        public async Task RemoveReactionAsync(int messageId, int userId, string emoji)
        {
            try
            {
                _logger.LogInformation("Removing reaction from message {MessageId}", messageId);
                var response = await _http.DeleteAsync(
                    $"api/messages/{messageId}/reactions?userId={userId}&emoji={Uri.EscapeDataString(emoji)}");
                response.EnsureSuccessStatusCode();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error removing reaction from message {MessageId}", messageId);
                throw;
            }
        }
    }
}using GauntletSlack3.Services.Interfaces;
using GauntletSlack3.Shared.Models;
using System.Net.Http.Json;
using Microsoft.Extensions.Logging;

namespace GauntletSlack3.Services;

public class ChannelService : IChannelService
{
    private readonly HttpClient _httpClient;
    private readonly IUserStateService _userStateService;
    private readonly ILogger<ChannelService> _logger;

    public event EventHandler? OnChannelMembershipChanged;

    public ChannelService(HttpClient httpClient, IUserStateService userStateService, ILogger<ChannelService> logger)
    {
        _httpClient = httpClient;
        _userStateService = userStateService;
        _logger = logger;
    }

    public async Task<List<Channel>> GetUserChannelsAsync(int userId)
    {
        Console.WriteLine($"Client: Requesting channels for user {userId}");
        var channels = await _httpClient.GetFromJsonAsync<List<Channel>>($"api/channels?userId={userId}");
        Console.WriteLine($"Client: Received {channels?.Count ?? 0} channels");
        return channels ?? new List<Channel>();
    }

    public async Task<Channel> CreateChannelAsync(string name, string type)
    {
        Console.WriteLine($"ChannelService: Creating channel {name} of type {type}");
        Console.WriteLine($"Current user ID: {_userStateService.CurrentUserId}");
        var request = new { Name = name, Type = type, UserId = _userStateService.CurrentUserId!.Value };
        var response = await _httpClient.PostAsJsonAsync("api/Channels", request);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<Channel>() ?? 
            throw new Exception("Failed to create channel");
    }

    public async Task<List<User>> GetChannelMembersAsync(int channelId)
    {
        return await _httpClient.GetFromJsonAsync<List<User>>($"api/Channels/{channelId}/members") 
            ?? new List<User>();
    }

    public async Task JoinChannelAsync(int channelId, int userId)
    {
        var response = await _httpClient.PostAsJsonAsync($"api/Channels/{channelId}/join", userId);
        if (!response.IsSuccessStatusCode)
        {
            throw new Exception("Failed to join channel");
        }
    }

    public async Task LeaveChannelAsync(int channelId, int userId)
    {
        _logger.LogInformation($"Leaving channel {channelId} as user {userId}");
        var response = await _httpClient.PostAsJsonAsync($"api/channels/{channelId}/leave", userId);
        response.EnsureSuccessStatusCode();
        OnChannelMembershipChanged?.Invoke(this, EventArgs.Empty);
    }
} namespace GauntletSlack3.Services.Interfaces;

public interface IUserStateService
{
    int? CurrentUserId { get; }
    bool IsUserOnline(int userId);
    Task SetUserOnlineStatus(int userId, bool isOnline);
    event EventHandler? OnUserStatusChanged;
    Task InitializeAsync();
} using GauntletSlack3.Shared.Models;

namespace GauntletSlack3.Services.Interfaces
{
    public interface IChannelService
    {
        event EventHandler? OnChannelMembershipChanged;
        Task<List<Channel>> GetUserChannelsAsync(int userId);
        Task<Channel> CreateChannelAsync(string name, string type);
        Task<List<User>> GetChannelMembersAsync(int channelId);
        Task JoinChannelAsync(int channelId, int userId);
        Task LeaveChannelAsync(int channelId, int userId);
    }
} using GauntletSlack3.Shared.Models;

namespace GauntletSlack3.Services.Interfaces
{
    public interface IMessageService
    {
        Task<List<Message>> GetChannelMessagesAsync(int channelId);
        Task<Message> SendMessageAsync(int channelId, int userId, string content);
        Task<Message> SendReplyAsync(int parentMessageId, int userId, string content);
        Task<Message?> GetMessageAsync(int messageId);
        Task AddReactionAsync(int messageId, int userId, string emoji);
        Task RemoveReactionAsync(int messageId, int userId, string emoji);
    }
} using GauntletSlack3.Shared.Models;

namespace GauntletSlack3.Services.Interfaces;

public interface IUserService
{
    Task<int> GetOrCreateUserAsync(string email, string name);
    Task<List<User>> GetUsersAsync();
    Task<User?> GetUserAsync(int userId);
    Task<bool> UpdateUserStatusAsync(int userId, bool isOnline);
    Task<int> GetCurrentUserId();
} public class AppState
{
    private readonly IMessageService _messageService;
    private readonly IChannelService _channelService;
    
    private Dictionary<int, List<Message>> _channelMessages = new();
    
    public event Action? OnChange;
    
    public async Task LoadChannelMessagesAsync(int channelId)
    {
        var messages = await _messageService.GetChannelMessagesAsync(channelId);
        _channelMessages[channelId] = messages;
        OnChange?.Invoke();
    }
} using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using GauntletSlack3;
using GauntletSlack3.Services;
using GauntletSlack3.Services.Interfaces;
using Microsoft.AspNetCore.Components.Authorization;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");
builder.RootComponents.Add<HeadOutlet>("head::after");

builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri("http://localhost:5256") });

// Services
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IChannelService, ChannelService>();
builder.Services.AddScoped<IMessageService, MessageService>();
builder.Services.AddScoped<RealTimeService>();
builder.Services.AddScoped<UserStateService>();
builder.Services.AddScoped<IUserStateService>(sp => sp.GetRequiredService<UserStateService>());

// Auth configuration
builder.Services.AddAuthorizationCore();
builder.Services.AddMsalAuthentication(options =>
{
    var authentication = options.ProviderOptions.Authentication;
    builder.Configuration.Bind("AzureAd", authentication);
    
    options.ProviderOptions.DefaultAccessTokenScopes.Add("openid");
    options.ProviderOptions.DefaultAccessTokenScopes.Add("profile");
    
    // If you're using Microsoft Graph API
    options.ProviderOptions.DefaultAccessTokenScopes.Add("https://graph.microsoft.com/User.Read");
    
    options.ProviderOptions.LoginMode = "redirect";
});

await builder.Build().RunAsync();
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using Xunit;
using Moq;
using Microsoft.Extensions.Logging;
using GauntletSlack3.Services;
using GauntletSlack3.Models;

public class MessageServiceTests
{
    private readonly Mock<HttpClient> _httpClientMock;
    private readonly Mock<ILogger<MessageService>> _loggerMock;
    private readonly MessageService _messageService;

    [Fact]
    public async Task SendMessageAsync_ValidMessage_ReturnsSuccess()
    {
        // Arrange
        var message = new Message { Content = "Test", ChannelId = 1, UserId = 1 };

        // Act
        var result = await _messageService.SendMessageAsync(message.ChannelId, message.UserId, message.Content);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(message.Content, result.Content);
    }
} //------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("GauntletSlack3.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+184625228a7e069bf2fe10e13b324bca60bdf1e9")]
[assembly: System.Reflection.AssemblyProductAttribute("GauntletSlack3.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("GauntletSlack3.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
using System.Collections.Generic;

namespace GauntletSlack3.Shared.Models;

public class Channel
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty;
    public int OwnerId { get; set; }
    public DateTime CreatedAt { get; set; }

    public virtual User? Owner { get; set; }
    public virtual ICollection<Message> Messages { get; set; } = new List<Message>();
    public virtual ICollection<ChannelMembership> Memberships { get; set; } = new List<ChannelMembership>();
} namespace GauntletSlack3.Shared.Models;

public class ChannelUser
{
    public int ChannelId { get; set; }
    public int UserId { get; set; }
    public virtual Channel? Channel { get; set; }
} namespace GauntletSlack3.Shared.Models;

public class Message
{
    public int Id { get; set; }
    public string Content { get; set; } = string.Empty;
    public int UserId { get; set; }
    public int ChannelId { get; set; }
    public DateTime CreatedAt { get; set; }
    public int? ParentMessageId { get; set; }

    // Navigation properties
    public virtual User? User { get; set; }
    public virtual Channel? Channel { get; set; }
    public Message? ParentMessage { get; set; }
    public List<Message> Replies { get; set; } = new();
    public List<MessageReaction> Reactions { get; set; } = new();
}

public class MessageReaction
{
    public int Id { get; set; }
    public int MessageId { get; set; }
    public int UserId { get; set; }
    public string Emoji { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public Message? Message { get; set; }
    public User? User { get; set; }
} namespace GauntletSlack3.Shared.Models
{
    public class ChannelMembership
    {
        public int ChannelId { get; set; }
        public int UserId { get; set; }
        public DateTime JoinedAt { get; set; }
        public bool IsMuted { get; set; }

        public virtual Channel? Channel { get; set; }
        public virtual User? User { get; set; }
    }
} namespace GauntletSlack3.Shared.Models;

public class User
{
    public int Id { get; set; }
    public required string Name { get; set; }
    public string Email { get; set; } = string.Empty;
    public bool IsAdmin { get; set; }
    public bool IsOnline { get; set; }

    // Navigation properties
    public virtual ICollection<Channel>? OwnedChannels { get; set; }
    public virtual ICollection<Message>? Messages { get; set; }
    public virtual ICollection<ChannelMembership>? Memberships { get; set; }
} namespace GauntletSlack3.Shared.Models
{
    public class UserCreateRequest
    {
        public required string Email { get; set; }
        public required string Name { get; set; }
    }
} ï»¿namespace GauntletSlack3.Shared;

public class Class1
{

}
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>
